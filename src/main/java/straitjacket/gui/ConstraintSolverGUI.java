/*
 * ConstraintSolverGUI.java
 *
 * Created on 24. Juli 2006, 16:40
 */

package straitjacket.gui;

import straitjacket.ArcConsistency;
import straitjacket.Backtracker;
import straitjacket.ConstraintSet;
import straitjacket.Variable;
import straitjacket.VariableNameExistsException;
import straitjacket.constraints.AllDifferentConstraint;

import javax.swing.*;

import static straitjacket.strategies.StrategyFactory.AvailableStrategies;

/**
 * @author  peach
 */
public class ConstraintSolverGUI extends javax.swing.JFrame {
    
    public static final long serialVersionUID = 1000;
    private Integer[][] lastSudokuMaskState;
    
    /** Creates new form ConstraintSolverGUI */
    private ConstraintSolverGUI() {
        this.initComponents();
        this.saveSodukuMaskState();
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">                          
    private void initComponents() {
        JTabbedPane jTabbedPane1 = new JTabbedPane();
        JPanel jPanel1 = new JPanel();
        sudokuMask = new straitjacket.gui.SudokuPanel();
        JPanel jPanel3 = new JPanel();
        constrainDiagsCheckbox = new javax.swing.JCheckBox();
        JButton sudokuSolve = new JButton();
        initialAC3Checkbox = new javax.swing.JCheckBox();
        useForwardCheckingCheckbox = new javax.swing.JCheckBox();
        JButton jButton2 = new JButton();
        jComboBox1 = new javax.swing.JComboBox(new javax.swing.DefaultComboBoxModel(straitjacket.strategies.StrategyFactory.AvailableStrategies.values()));
        JLabel jLabel1 = new JLabel();
        JButton jButton1 = new JButton();
        JButton emptyButton = new JButton();
        progressBar = new javax.swing.JProgressBar();
        JLabel jLabel2 = new JLabel();
        JLabel jLabel3 = new JLabel();
        iterationsLabel = new javax.swing.JLabel();
        timeLabel = new javax.swing.JLabel();
        JLabel jLabel4 = new JLabel();
        timeOverallLabel = new javax.swing.JLabel();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        sudokuMask.setToolTipText("fill in numbers");

        constrainDiagsCheckbox.setText("constrain diagonals, too");
        constrainDiagsCheckbox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        constrainDiagsCheckbox.setMargin(new java.awt.Insets(0, 0, 0, 0));

        sudokuSolve.setText("solve");
        sudokuSolve.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                sudokuSolveActionPerformed();
            }
        });

        initialAC3Checkbox.setSelected(true);
        initialAC3Checkbox.setText("initial AC3");
        initialAC3Checkbox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        initialAC3Checkbox.setMargin(new java.awt.Insets(0, 0, 0, 0));

        useForwardCheckingCheckbox.setSelected(true);
        useForwardCheckingCheckbox.setText("use forward checking");
        useForwardCheckingCheckbox.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
        useForwardCheckingCheckbox.setMargin(new java.awt.Insets(0, 0, 0, 0));

        jButton2.setText("reset");
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                resetSudokuMask();
            }
        });

        jLabel1.setText("Strategy:");

        jButton1.setText("abort");

        emptyButton.setText("empty");
        emptyButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                emptyButtonPressed();
            }
        });

        progressBar.setFocusable(false);
        progressBar.setString("solving... please stand by...");

        jLabel2.setText("backtracker iterations: ");

        jLabel3.setText("backtracker time:");

        iterationsLabel.setText("0");

        timeLabel.setText("0 ms");

        jLabel4.setText("overall time:");

        timeOverallLabel.setText("0 ms");

        org.jdesktop.layout.GroupLayout jPanel3Layout = new org.jdesktop.layout.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .add(jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(initialAC3Checkbox)
                    .add(useForwardCheckingCheckbox)
                    .add(constrainDiagsCheckbox)
                    .add(jPanel3Layout.createSequentialGroup()
                        .add(jLabel1)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(jComboBox1, 0, 178, Short.MAX_VALUE))
                    .add(jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING, false)
                        .add(org.jdesktop.layout.GroupLayout.LEADING, jPanel3Layout.createSequentialGroup()
                            .add(jButton2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 113, Short.MAX_VALUE)
                            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                            .add(emptyButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 113, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                        .add(org.jdesktop.layout.GroupLayout.LEADING, jPanel3Layout.createSequentialGroup()
                            .add(jButton1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 105, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                            .add(sudokuSolve, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 65, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                    .add(progressBar, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 232, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jPanel3Layout.createSequentialGroup()
                        .add(jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(jLabel2)
                            .add(jLabel3))
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(timeLabel)
                            .add(iterationsLabel)))
                    .add(jPanel3Layout.createSequentialGroup()
                        .add(jLabel4)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(timeOverallLabel)))
                .addContainerGap())
        );

        jPanel3Layout.linkSize(new java.awt.Component[] {jLabel2, jLabel3, jLabel4}, org.jdesktop.layout.GroupLayout.HORIZONTAL);

        jPanel3Layout.linkSize(new java.awt.Component[] {emptyButton, jButton1, jButton2, sudokuSolve}, org.jdesktop.layout.GroupLayout.HORIZONTAL);

        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel3Layout.createSequentialGroup()
                .addContainerGap()
                .add(initialAC3Checkbox)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(useForwardCheckingCheckbox)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(constrainDiagsCheckbox)
                .add(12, 12, 12)
                .add(jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel1)
                    .add(jComboBox1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 38, Short.MAX_VALUE)
                .add(jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel2)
                    .add(iterationsLabel))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel3)
                    .add(timeLabel))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel4)
                    .add(timeOverallLabel))
                .add(13, 13, 13)
                .add(progressBar, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .add(19, 19, 19)
                .add(jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jButton2)
                    .add(emptyButton))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jButton1)
                    .add(sudokuSolve))
                .addContainerGap())
        );

        org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .add(sudokuMask, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .add(jPanel3, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, sudokuMask, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jPanel3, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        jTabbedPane1.addTab("Sudoku", jPanel1);

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(jTabbedPane1)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(layout.createSequentialGroup()
                .addContainerGap()
                .add(jTabbedPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 416, Short.MAX_VALUE)
                .addContainerGap())
        );
        pack();
    }// </editor-fold>                        

    private void emptyButtonPressed() {
        int fieldSize = ((SudokuPanel)this.sudokuMask).getFieldSize();

        // reset the time and iteration labels
        this.timeOverallLabel.setText("0 ms");
        this.timeLabel.setText("0 ms");
        this.iterationsLabel.setText("");
        
        // empty history and sudoku mask
        for ( int i=0; i<fieldSize; i++) {
            for ( int j=0; j<fieldSize; j++) {
                this.lastSudokuMaskState[i][j] = null;
                ((SudokuPanel)this.sudokuMask).setValueAt(i,j,this.lastSudokuMaskState[i][j]);
            }
        }
    }                                   

    private void resetSudokuMask() {
        int fieldSize = ((SudokuPanel)this.sudokuMask).getFieldSize();
        
        // reset the time and iteration labels
        this.timeOverallLabel.setText("0 ms");
        this.timeLabel.setText("0 ms");
        this.iterationsLabel.setText("0");
        
        // initialize history if neccessary
        if (this.lastSudokuMaskState == null)
            this.lastSudokuMaskState = new Integer[fieldSize][fieldSize];
        
        // reset existing values
        for ( int i=0; i<fieldSize; i++)
            for ( int j=0; j<fieldSize; j++)
                ((SudokuPanel)this.sudokuMask).setValueAt(i,j,this.lastSudokuMaskState[i][j]);
    }                                

    private void saveSodukuMaskState() {
        int fieldSize = ((SudokuPanel)this.sudokuMask).getFieldSize();
        
        // initialize history if neccessary
        if (this.lastSudokuMaskState == null)
            this.lastSudokuMaskState = new Integer[fieldSize][fieldSize];
        
        // save existing values to history
        for ( int i=0; i<fieldSize; i++) {
            for ( int j=0; j<fieldSize; j++) {
                String strValue = ((SudokuPanel)this.sudokuMask).getValueAt(i,j);
                if ( strValue != null ) {
                    int value = Integer.parseInt(strValue);
                    if ( value != 0 )
                        this.lastSudokuMaskState[i][j] = value;
                    else 
                        this.lastSudokuMaskState[i][j] = null;
                } else {
                    this.lastSudokuMaskState[i][j] = null;
                }
            }
        }
    }
    
    private void sudokuSolveActionPerformed() {
        // saving what the user has entered
        this.saveSodukuMaskState();
        
        // inform the user that we are processing
        this.progressBar.setString("solving... please stand by...");
        this.progressBar.setStringPainted(true);
        this.progressBar.repaint();
        
        // getting the field size
        int blockSize = ((SudokuPanel)this.sudokuMask).getBlockSize();
        int fieldSize = ((SudokuPanel)this.sudokuMask).getFieldSize();
        
        ConstraintSet cs = new ConstraintSet();
        Variable[][] cells = new Variable[fieldSize][fieldSize];

        // set up the variables... this could be more elegant using models
        for ( int i=0; i<fieldSize; i++) {
            for ( int j=0; j<fieldSize; j++) {
                try {
                    cells[i][j] = cs.addVariable("sud_"+i+"_"+j,1,fieldSize);
                } catch (VariableNameExistsException e) {
                    System.out.println("A Variable with that name already exists!");
                }
                String strValue = ((SudokuPanel)this.sudokuMask).getValueAt(i,j);
                if ( strValue != null ) {
                    int value = Integer.parseInt(strValue);
                    if ( value != 0 ) {
                        cells[i][j].setDomain(value);
                    }
                } 
            }
        }
    
        // set up the alldifferent constraints for the rows and columns
        for (int x = 0; x<fieldSize; x++) {
            // alldifferent for row
            cs.add( new AllDifferentConstraint(cells[x]) );
            
            // alldifferent for column
            Variable[] col = new Variable[fieldSize];
            for ( int i=0; i<fieldSize; i++ ) {
                col[i] = cells[i][x];
            }
            cs.add( new AllDifferentConstraint(col) );
            
        }
        
        // set up the alldifferent constraints for the blocks
        for ( int a = 0; a<blockSize; a++ ) {
            for ( int b = 0; b<blockSize; b++ ) {
                Variable[] block = new Variable[fieldSize];
                for ( int i = 0; i<blockSize; i++ )
                    System.arraycopy(cells[a * blockSize + i], b * blockSize, block, i * blockSize, blockSize);
                cs.add( new AllDifferentConstraint(block) );
            }
        }
        
        // constrain the diagonals, too if wanted
        if (this.constrainDiagsCheckbox.isSelected()) {
            Variable[] diag1 = new Variable[fieldSize];
            Variable[] diag2 = new Variable[fieldSize];
            
            for ( int d=0; d<fieldSize; d++) {
                diag1[d] = cells[d][d];
                diag2[d] = cells[d][fieldSize-d-1];
            }
            
            cs.add( new AllDifferentConstraint(diag1) );
            cs.add( new AllDifferentConstraint(diag2) );
        }
        
        // get the selected strategy
        AvailableStrategies strat = (AvailableStrategies)this.jComboBox1.getSelectedItem();
        
        System.out.println("Solving using " + strat + " strategy...\n" + cs);
        
        // take the time
        long overallTime = System.currentTimeMillis();
                
        // initial AC3 if wanted
        if ( this.initialAC3Checkbox.isSelected() ) {
            System.out.println("Initial AC3...\n");
            ArcConsistency.ac3(cs);
            System.out.println("" + cs);
        }
        
        // does the user want forward checking?
        if ( this.useForwardCheckingCheckbox.isSelected() ) {
            Backtracker.backtrackSolveForwardCheck(cs,strat);
        } else {
            Backtracker.backtrackSolve(cs,strat);
        }
        
        // take the time
        overallTime = System.currentTimeMillis() - overallTime;
        
        // update iteration and time information
        this.timeOverallLabel.setText("" + overallTime + " ms");
        this.iterationsLabel.setText("" + Backtracker.getIterations());
        this.timeLabel.setText("" + Backtracker.getTime() + " ms");
        
        // update the sudokuMask with the solution
        for ( int i=0; i<fieldSize; i++) {
            for ( int j=0; j<fieldSize; j++) {
                if ( cells[i][j].isTiedToValue() ) {
                    ((SudokuPanel)this.sudokuMask).setValueAt(i,j,cells[i][j].getTiedValue());
                } else {
                    int[] v = cells[i][j].getDomain().validToArray();
                    if ( v.length > 1 ) {
                        // this should never happen... there should be a concrete
                        // variable assignment
                        System.out.println("No conrete variable assignment in " + cells[i][j] );                   
                    } else if ( v.length < 1 ) {
                        ((SudokuPanel)this.sudokuMask).setValueAt(i,j,0);
                    } else {
                        ((SudokuPanel)this.sudokuMask).setValueAt(i,j,v[0]);
                    }
                }                 
            }
        }
        
        // inform the user that we have finished processing
        this.progressBar.setStringPainted(false);
        
    }                                           
    
    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new ConstraintSolverGUI().setVisible(true);
            }
        });
    }
    
    // Variables declaration - do not modify                     
    private javax.swing.JCheckBox constrainDiagsCheckbox;
    private javax.swing.JCheckBox initialAC3Checkbox;
    private javax.swing.JLabel iterationsLabel;
    private javax.swing.JComboBox jComboBox1;
    private javax.swing.JProgressBar progressBar;
    private javax.swing.JPanel sudokuMask;
    private javax.swing.JLabel timeLabel;
    private javax.swing.JLabel timeOverallLabel;
    private javax.swing.JCheckBox useForwardCheckingCheckbox;
    // End of variables declaration                   
    
}